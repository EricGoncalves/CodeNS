#define WITH_MPI



module mod_mpi
#if defined(WITH_MPI)
  USE MPI
#endif
      implicit none
      integer :: rank
      integer :: NPROCS
!      integer,allocatable :: block2proc(:)
INTERFACE SUM_MPI
!      SUM_MPI(A,B)
! COMPUTE THE SUM OF A IN B
   MODULE PROCEDURE SUM_MPI_0R,SUM_MPI_0I,&
                    SUM_MPI_1R,SUM_MPI_1I
END INTERFACE SUM_MPI

INTERFACE BCAST
!        BCAST(A,ORIG)
! BROADCAST THE MESSAGE A FROM ORIG FOR EVERY PROC
! RETURN WHEN EVERYTHING IS DONE
   MODULE PROCEDURE BCAST_0R,BCAST_0I,&
                    BCAST_1R,BCAST_1I,&
                    BCAST_2R,BCAST_2I
END INTERFACE BCAST

INTERFACE GATHER
! THIS ROUTINE IS GATHERING DATA FOR EVERY PROC FROM EVERY PROC
! EXEMPLE
! PROC 1 : IN=[A,B,C,D] , SIZE=3 , OUT=[A,B,C,E,F]
! PROC 2 : IN=[E,F]     , SIZE=2 , OUT=[A,B,C,E,F]
! PROC 3 : IN=[]        , SIZE=0 , OUT=[A,B,C,E,F]
! MPI_ALLGATHERV(IN, SIZE, MPI_TYPE(IN),OUT, SIZE(OUT), SHIFT, MPI_TYPE(OUT), MPI_COMM_WORLD,IERR)
   MODULE PROCEDURE GATHER_R,GATHER_I
END INTERFACE GATHER

INTERFACE MPI_TRANS
!        SEND A MESSAGE WITH MPI
   MODULE PROCEDURE MPI_TRANS_R1,MPI_TRANS_R2,MPI_TRANS_I,MPI_TRANS_I0
END INTERFACE MPI_TRANS

      contains

!************************************
  SUBROUTINE  INIMPI
!************************************
    IMPLICIT NONE
  integer :: ierr

#if defined(WITH_MPI)
    CALL MPI_INIT(IERR)
    CALL MPI_COMM_RANK(MPI_COMM_WORLD, RANK, IERR)
    CALL MPI_COMM_SIZE(MPI_COMM_WORLD, NPROCS, IERR)
#else
      RANK=0
      NPROCS=1
#endif

  END SUBROUTINE  INIMPI

  subroutine endmpi
  implicit none
  integer :: ierr
#if defined(WITH_MPI)
  CALL MPI_FINALIZE(IERR)
#endif

  end subroutine endmpi




  SUBROUTINE MPI_TRANS_R1(A,B,ORIG,DEST)
!ORIG SEND THE MESSAGE A TO DEST
!DEST RECV THE MESSAGE B FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    double precision   ,INTENT(INOUT) :: A(:)
    double precision   ,INTENT(IN)    :: B(:)
    integer,INTENT(IN)    :: ORIG,DEST
#ifdef WITH_MPI
    integer :: STATUS(MPI_STATUS_SIZE),TAG
  integer :: ierr
#endif

IF (RANK==ORIG.AND.RANK==DEST) THEN ! SENDING A MESSAGE TO MYSELF
    A=B
#ifdef WITH_MPI
ELSE
    TAG=ORIG*NPROCS+DEST

    IF(RANK==ORIG)  & ! I'M ORIG, I SEND THE MESSAGE B TO DEST
        CALL MPI_SEND(B,SIZE(B),MPI_REAL8,DEST, &
                      TAG,MPI_COMM_WORLD,IERR)

    IF(RANK==DEST) &  ! I'M DEST, I RECIEVE THE MESSAGE A FORM ORIG
        CALL MPI_RECV(A,SIZE(A),MPI_REAL8,ORIG, &
                      TAG,MPI_COMM_WORLD,STATUS,IERR)
#endif
ENDIF

  END SUBROUTINE MPI_TRANS_R1

  SUBROUTINE MPI_TRANS_R2(A,B,ORIG,DEST)
!ORIG SEND THE MESSAGE A TO DEST
!DEST RECV THE MESSAGE B FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    double precision   ,INTENT(INOUT) :: A(:,:)
    double precision   ,INTENT(IN)    :: B(:,:)
    integer,INTENT(IN)    :: ORIG,DEST
#ifdef WITH_MPI
    integer :: STATUS(MPI_STATUS_SIZE),TAG
  integer :: ierr
#endif

IF (RANK==ORIG.AND.RANK==DEST) THEN ! SENDING A MESSAGE TO MYSELF
    A=B
#ifdef WITH_MPI
ELSE
    TAG=ORIG*NPROCS+DEST

    IF(RANK==ORIG)  & ! I'M ORIG, I SEND THE MESSAGE B TO DEST
        CALL MPI_SEND(B,SIZE(B),MPI_REAL8,DEST, &
                      TAG,MPI_COMM_WORLD,IERR)

    IF(RANK==DEST) &  ! I'M DEST, I RECIEVE THE MESSAGE A FORM ORIG
        CALL MPI_RECV(A,SIZE(A),MPI_REAL8,ORIG, &
                      TAG,MPI_COMM_WORLD,STATUS,IERR)
#endif
ENDIF

  END SUBROUTINE MPI_TRANS_R2

  SUBROUTINE MPI_TRANS_I(A,B,ORIG,DEST)
!ORIG SEND THE MESSAGE A TO DEST
!DEST RECV THE MESSAGE B FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer,INTENT(INOUT) :: A(:)
    integer,INTENT(IN)    :: B(:)
    integer,INTENT(IN)    :: ORIG,DEST
#ifdef WITH_MPI
    integer :: STATUS(MPI_STATUS_SIZE),TAG
  integer :: ierr
#endif

IF (RANK==ORIG.AND.RANK==DEST) THEN ! SENDING A MESSAGE TO MYSELF
    A=B
#ifdef WITH_MPI
ELSE
    TAG=ORIG*NPROCS+DEST

    IF(RANK==ORIG)  & ! I'M ORIG, I SEND THE MESSAGE B TO DEST
        CALL MPI_SEND(B,SIZE(B),MPI_INTEGER,DEST, &
                      TAG,MPI_COMM_WORLD,IERR)

    IF(RANK==DEST) &  ! I'M DEST, I RECIEVE THE MESSAGE A FORM ORIG
        CALL MPI_RECV(A,SIZE(A),MPI_INTEGER,ORIG, &
                      TAG,MPI_COMM_WORLD,STATUS,IERR)
#endif
ENDIF

  END SUBROUTINE MPI_TRANS_I


  SUBROUTINE MPI_TRANS_I0(A,B,ORIG,DEST)
!ORIG SEND THE MESSAGE A TO DEST
!DEST RECV THE MESSAGE B FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer,INTENT(INOUT) :: A
    integer,INTENT(IN)    :: B
    integer,INTENT(IN)    :: ORIG,DEST
#ifdef WITH_MPI
    integer :: STATUS(MPI_STATUS_SIZE),TAG
  integer :: ierr
#endif

IF (RANK==ORIG.AND.RANK==DEST) THEN ! SENDING A MESSAGE TO MYSELF
    A=B
#ifdef WITH_MPI
ELSE
    TAG=ORIG*NPROCS+DEST

    IF(RANK==ORIG)  & ! I'M ORIG, I SEND THE MESSAGE B TO DEST
        CALL MPI_SEND(B,1,MPI_INTEGER,DEST, &
                      TAG,MPI_COMM_WORLD,IERR)

    IF(RANK==DEST) &  ! I'M DEST, I RECIEVE THE MESSAGE A FORM ORIG
        CALL MPI_RECV(A,1,MPI_INTEGER,ORIG, &
                      TAG,MPI_COMM_WORLD,STATUS,IERR)
#endif
ENDIF

  END SUBROUTINE MPI_TRANS_I0

  SUBROUTINE MPI_ITRANS_BEGIN(A,ORIG,DEST,REQS,REQR)
!PREPARE THE REQUESTS ARRAY
    IMPLICIT NONE
    double precision   ,INTENT(INOUT) :: A(:)
    integer,INTENT(IN)    :: ORIG,DEST
    integer,INTENT(INOUT) :: REQS,REQR
  integer :: ierr
    integer :: TAG

#ifdef WITH_MPI
TAG = (ORIG+1)*NPROCS*2+DEST+1

IF(DEST/=ORIG) THEN
    CALL MPI_SEND_INIT(A, SIZE(A), MPI_REAL8, DEST, &
                      TAG, MPI_COMM_WORLD,REQS,IERR)! SEND THE BUFFER
    CALL MPI_RECV_INIT(A, SIZE(A), MPI_REAL8, ORIG, &
                      TAG, MPI_COMM_WORLD,REQR,IERR)! RECV THE BUFFER
ENDIF
#endif

  END SUBROUTINE MPI_ITRANS_BEGIN

  SUBROUTINE MPI_ITRANS(REQ)
!ORIG SEND THE MESSAGE A TO DEST
!DEST RECV THE MESSAGE B FROM ORIG
!RETURN WHEN EVERYTHING IS STARTED 
!(THE MESSAGES HAVEN'T BEEN DELIVERED YET)
    IMPLICIT NONE
    integer,INTENT(INOUT) :: REQ
  integer :: ierr

#ifdef WITH_MPI
IF(REQ/=MPI_REQUEST_NULL)  CALL MPI_START(REQ,IERR)
#endif

  END SUBROUTINE MPI_ITRANS

  SUBROUTINE WAIT_MPI(REQ)
!WAIT FOR A COMMUNICATION TO END
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer :: REQ
#ifdef WITH_MPI
    integer :: STATUS(MPI_STATUS_SIZE)
  integer :: ierr

IF(REQ/=MPI_REQUEST_NULL)   CALL MPI_WAIT(REQ, STATUS, IERR)
#endif

  END SUBROUTINE WAIT_MPI

  SUBROUTINE BARRIER()
! SYNC POINT FOR ALL PROCESS
    IMPLICIT NONE
  integer :: ierr
#ifdef WITH_MPI
  CALL MPI_Barrier(MPI_COMM_WORLD,IERR )
#endif

  END SUBROUTINE BARRIER

SUBROUTINE GATHER_P(IN,OUT)
! THIS ROUTINE IS GATHERING INTEGER FOR EVERY PROC FROM EVERY PROC
! EXEMPLE
! PROC 1 : IN=A , OUT=[A,B,C]
! PROC 2 : IN=B , OUT=[A,B,C]
! PROC 3 : IN=C , OUT=[A,B,C]
  IMPLICIT NONE
  integer,INTENT(IN)  :: IN
  integer,INTENT(OUT) :: OUT(:)
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLGATHER(IN, 1, MPI_INTEGER, OUT, 1, MPI_INTEGER, MPI_COMM_WORLD,IERR)
#else
  OUT(:)=IN
#endif

END SUBROUTINE GATHER_P

SUBROUTINE MAXLOC_MPI(IN,OUT)
  IMPLICIT NONE
! THIS ROUTINE IS SEARCHING FOR THE MAX OF IN(1,J)
! IN(2,J) IS USED TO IDENTIFY THE OWNER OF THE MAX VALUE
! EXEMPLE
! PROC 1 : IN=[A,1,B,1] , OUT=[A,1,B,2]
! PROC 2 : IN=[C,2,D,2] , OUT=[A,1,B,2]

  double precision,INTENT(IN)    ::  IN(:,:)
  double precision,INTENT(INOUT) :: OUT(:,:)
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLREDUCE(IN, OUT, SIZE(IN,2), MPI_2DOUBLE_PRECISION,MPI_MAXLOC, MPI_COMM_WORLD,IERR)
#endif

END SUBROUTINE MAXLOC_MPI

SUBROUTINE LOR_MPI(IN,OUT)
  IMPLICIT NONE
! THIS ROUTINE COMPUTE AN "OR" OPERATION BETWEEN IN

  LOGICAL,INTENT(IN)  ::  IN
  LOGICAL,INTENT(OUT) :: OUT
  integer :: ierr
#ifdef WITH_MPI
      CALL MPI_ALLREDUCE(IN, OUT, 1, MPI_LOGICAL,MPI_LOR, MPI_COMM_WORLD,IERR)
#else
    OUT=IN
#endif

END SUBROUTINE LOR_MPI

SUBROUTINE FREE_MPI_REQ(REQ)
  IMPLICIT NONE
! THIS ROUTINE COMPUTE AN "OR" OPERATION BETWEEN IN

  integer,INTENT(INOUT)  ::  REQ
  integer :: ierr
#ifdef WITH_MPI
  if(req/=MPI_REQUEST_NULL) CALL MPI_REQUEST_FREE(REQ,IERR)
#endif

END SUBROUTINE FREE_MPI_REQ



SUBROUTINE REALLOCATE_1R(IN,SIZE)
  IMPLICIT NONE
  double precision,ALLOCATABLE,INTENT(INOUT) :: IN(:)
  integer,INTENT(IN)             :: SIZE

  IF(ALLOCATED(IN)) DEALLOCATE(IN)
  ALLOCATE(IN(SIZE))
  
END SUBROUTINE REALLOCATE_1R

SUBROUTINE REALLOCATE_2R(IN,SIZE1,SIZE2)
  IMPLICIT NONE
  double precision,ALLOCATABLE,INTENT(INOUT) :: IN(:,:)
  integer,INTENT(IN)             :: SIZE1,SIZE2

  IF(ALLOCATED(IN)) DEALLOCATE(IN)
  ALLOCATE(IN(SIZE1,SIZE2))
  
END SUBROUTINE REALLOCATE_2R

SUBROUTINE REALLOCATE_3R(IN,SIZE1,SIZE2,SIZE3)
  IMPLICIT NONE
  double precision,ALLOCATABLE,INTENT(INOUT) :: IN(:,:,:)
  integer,INTENT(IN)             :: SIZE1,SIZE2,SIZE3

  IF(ALLOCATED(IN)) DEALLOCATE(IN)
  ALLOCATE(IN(SIZE1,SIZE2,SIZE3))
  
END SUBROUTINE REALLOCATE_3R


SUBROUTINE REALLOCATE_1I(IN,SIZE)
  IMPLICIT NONE
  integer,ALLOCATABLE,INTENT(INOUT) :: IN(:)
  integer,INTENT(IN)                :: SIZE

  IF(ALLOCATED(IN)) DEALLOCATE(IN)
  ALLOCATE(IN(SIZE))
  
END SUBROUTINE REALLOCATE_1I

SUBROUTINE REALLOCATE_2I(IN,SIZE1,SIZE2)
  IMPLICIT NONE
  integer,ALLOCATABLE,INTENT(INOUT) :: IN(:,:)
  integer,INTENT(IN)                :: SIZE1,SIZE2

  IF(ALLOCATED(IN)) DEALLOCATE(IN)
  ALLOCATE(IN(SIZE1,SIZE2))
  
END SUBROUTINE REALLOCATE_2I

SUBROUTINE REALLOCATE_3I(IN,SIZE1,SIZE2,SIZE3)
  IMPLICIT NONE
  integer,ALLOCATABLE,INTENT(INOUT) :: IN(:,:,:)
  integer,INTENT(IN)                :: SIZE1,SIZE2,SIZE3

  IF(ALLOCATED(IN)) DEALLOCATE(IN)
  ALLOCATE(IN(SIZE1,SIZE2,SIZE3))
  
END SUBROUTINE REALLOCATE_3I

  SUBROUTINE SUM_MPI_0R(A,B)
!COMPUTE THE SUM OF A IN B
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    double precision   ,INTENT(IN)    :: A
    double precision   ,INTENT(INOUT) :: B
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLREDUCE(A, B, 1, MPI_REAL8,MPI_SUM, MPI_COMM_WORLD,IERR)
#else
    B=A
#endif

  END SUBROUTINE SUM_MPI_0R

  SUBROUTINE SUM_MPI_1R(A,B)
!COMPUTE THE SUM OF A IN B
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    double precision   ,INTENT(IN)    :: A(:)
    double precision   ,INTENT(INOUT) :: B(:)
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLREDUCE(A, B, SIZE(A), MPI_REAL8,MPI_SUM, MPI_COMM_WORLD,IERR)
#else
    B=A
#endif

  END SUBROUTINE SUM_MPI_1R


  SUBROUTINE SUM_MPI_0I(A,B)
!COMPUTE THE SUM OF A IN B
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer   ,INTENT(IN)    :: A
    integer   ,INTENT(INOUT) :: B
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLREDUCE(A, B, 1, MPI_INTEGER,MPI_SUM, MPI_COMM_WORLD,IERR)
#else
    B=A
#endif

  END SUBROUTINE SUM_MPI_0I

  SUBROUTINE SUM_MPI_1I(A,B)
!COMPUTE THE SUM OF A IN B
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer   ,INTENT(IN)    :: A(:)
    integer   ,INTENT(INOUT) :: B(:)
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLREDUCE(A, B, SIZE(A), MPI_INTEGER,MPI_SUM, MPI_COMM_WORLD,IERR)
#else
    B=A
#endif

  END SUBROUTINE SUM_MPI_1I

  SUBROUTINE BCAST_0I(IN,ORIG)
!BROADCAST THE MESSAGE IN FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer   ,INTENT(INOUT) :: IN
    integer,INTENT(IN)    :: ORIG
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_BCAST( IN,1, MPI_INTEGER, ORIG, MPI_COMM_WORLD,IERR)
#endif

  END SUBROUTINE BCAST_0I

  SUBROUTINE BCAST_0R(IN,ORIG)
!BROADCAST THE MESSAGE IN FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    double precision   ,INTENT(INOUT) :: IN
    integer,INTENT(IN)    :: ORIG
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_BCAST( IN,1, MPI_REAL8, ORIG, MPI_COMM_WORLD,IERR)
#endif

  END SUBROUTINE BCAST_0R

  SUBROUTINE BCAST_1R(IN,ORIG)
!BROADCAST THE MESSAGE IN FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    double precision   ,INTENT(INOUT) :: IN(:)
    integer,INTENT(IN)    :: ORIG
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_BCAST( IN,SIZE(IN), MPI_REAL8, ORIG, MPI_COMM_WORLD,IERR)
#endif

  END SUBROUTINE BCAST_1R

  SUBROUTINE BCAST_2R(IN,ORIG)
!BROADCAST THE MESSAGE IN FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    double precision   ,INTENT(INOUT) :: IN(:,:)
    integer,INTENT(IN)    :: ORIG
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_BCAST( IN,SIZE(IN), MPI_REAL8, ORIG, MPI_COMM_WORLD,IERR)
#endif

  END SUBROUTINE BCAST_2R

  SUBROUTINE BCAST_1I(IN,ORIG)
!BROADCAST THE MESSAGE IN FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer,INTENT(INOUT) :: IN(:)
    integer,INTENT(IN)    :: ORIG
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_BCAST( IN,SIZE(IN), MPI_INTEGER, ORIG, MPI_COMM_WORLD,IERR)
#endif

  END SUBROUTINE BCAST_1I

  SUBROUTINE BCAST_2I(IN,ORIG)
!BROADCAST THE MESSAGE IN FROM ORIG
!RETURN WHEN EVERYTHING IS DONE
    IMPLICIT NONE
    integer,INTENT(INOUT) :: IN(:,:)
    integer,INTENT(IN)    :: ORIG
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_BCAST( IN,SIZE(IN), MPI_INTEGER, ORIG, MPI_COMM_WORLD,IERR)
#endif

  END SUBROUTINE BCAST_2I

SUBROUTINE GATHER_I(IN,OUT,SIZE)
! THIS ROUTINE IS GATHERING INTEGER FOR EVERY PROC FROM EVERY PROC
! EXEMPLE
! PROC 1 : IN=[A,B,C,D] , SIZE=3 , OUT=[A,B,C,E,F]
! PROC 2 : IN=[E,F]     , SIZE=2 , OUT=[A,B,C,E,F]
! PROC 3 : IN=[]        , SIZE=0 , OUT=[A,B,C,E,F]
  IMPLICIT NONE
  integer,INTENT(IN)  :: IN(:),SIZE
  integer,INTENT(OUT) :: OUT(:)
  integer             :: I,DISP(NPROCS),SIZE_ALL(NPROCS)
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLGATHER(SIZE, 1, MPI_INTEGER, &
                       SIZE_ALL, 1, MPI_INTEGER, MPI_COMM_WORLD,IERR)
    DISP(1)=0
    DO I=2,NPROCS
     DISP(I)=DISP(I-1) + SIZE_ALL(I-1)
    ENDDO

    CALL MPI_ALLGATHERV(IN, SIZE, MPI_INTEGER, &
                        OUT, SIZE_ALL, DISP, MPI_INTEGER, MPI_COMM_WORLD,IERR)
#else
  OUT=IN
#endif

END SUBROUTINE GATHER_I

SUBROUTINE GATHER_R(IN,OUT,SIZE)
  IMPLICIT NONE
! THIS ROUTINE IS GATHERING REAL FOR EVERY PROC FROM EVERY PROC
! EXEMPLE
! PROC 1 : IN=[A,B,C,D] , SIZE=3 , OUT=[A,B,C,E,F]
! PROC 2 : IN=[E,F]     , SIZE=2 , OUT=[A,B,C,E,F]
! PROC 3 : IN=[]        , SIZE=0 , OUT=[A,B,C,E,F]

  double precision,INTENT(IN)     :: IN(:)
  integer,INTENT(IN)  :: SIZE
  double precision,INTENT(OUT)    :: OUT(:)
  integer             :: I,DISP(NPROCS),SIZE_ALL(NPROCS)
  integer :: ierr
#ifdef WITH_MPI
    CALL MPI_ALLGATHER(SIZE, 1, MPI_INTEGER, &
                       SIZE_ALL, 1, MPI_INTEGER, MPI_COMM_WORLD,IERR)
    DO I=1,NPROCS
     DISP(I)=SUM(SIZE_ALL(1:I-1))
    ENDDO

    CALL MPI_ALLGATHERV(IN, SIZE, MPI_REAL8, &
                        OUT, SIZE_ALL, DISP, MPI_REAL8, MPI_COMM_WORLD,IERR)
#else
  OUT=IN
#endif
END SUBROUTINE GATHER_R

end module mod_mpi
	  
